########################################
# v8.0.0 Refactor/Clean up and improved Gap logic
# v1.0.1 Remove old dispatched items
# Template to agragate the total of the dispatches
########################################
octopus_dispatches_template_octopus_dispatch:
  template:
    ######################################################
    # Octopus dispatch kWh
    ######################################################
    - sensor:
        - name: "Octopus Total Planned Dispatch"
          unique_id: octopus_total_planned_dispatch
          icon: mdi:ev-station
          unit_of_measurement: "kWh"
          device_class: energy
          state_class: total
          state: >
            {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching', 'planned_dispatches') or [] %}
            {% set ns2 = namespace(total_dispatch=0.0) %}
            {% for dispatch in planned %}
              {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                {# set ns2.total_dispatch = ns2.total_dispatch + ((dispatch.end|as_timestamp - dispatch.start|as_timestamp)/3600*6.9) #}
                {% set ns2.total_dispatch = ns2.total_dispatch + (((dispatch.charge_in_kwh)|float(0))*-1) %}
              {% endif %}
            {% endfor %}
            {{ 0 if ns2.total_dispatch < 0.5 else ns2.total_dispatch }}

          attributes:
            total_dispatches: >
              {{ (state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or []) | count }}

            dispatches: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set ns3 = namespace(members=[]) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set ns3.members = ns3.members + [{
                    "dispatch": (dispatch.start|as_datetime|as_local).strftime('%H:%M') 
                              ~ " to " 
                              ~ (dispatch.end|as_datetime|as_local).strftime('%H:%M')
                  }] %}
                {% endif %}
              {% endfor %}
              {{ ns3.members }}

            gaps: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set now_t = now() %}
              {% set ns = namespace(intervals=[], gaps=[], last_end=now_t.timestamp()) %}

              {# --- Collect all valid dispatch intervals --- #}
              {% for d in planned %}
                {% if d.start is not none and d.end is not none and as_datetime(d.end) > now() %}
                  {% set s_dt = as_local(as_datetime(d.start)) %}
                  {% set e_dt = as_local(as_datetime(d.end)) %}
                  {% if e_dt > now_t %}
                    {% set s_ts = max(s_dt.timestamp(), now_t.timestamp()) %}
                    {% set e_ts = e_dt.timestamp() %}
                    {% if e_ts > s_ts %}
                      {% set ns.intervals = ns.intervals + [(s_ts, e_ts)] %}
                    {% endif %}
                  {% endif %}
                {% endif %}
              {% endfor %}

              {# --- Sort intervals by start time --- #}
              {% set ns.intervals = ns.intervals | sort(attribute=0) %}

              {# --- Compute gaps between intervals --- #}
              {% for s, e in ns.intervals %}
                {% if s > ns.last_end %}
                  {% set gap_start = ns.last_end | timestamp_custom("%H:%M", true) %}
                  {% set gap_end = s | timestamp_custom("%H:%M", true) %}
                  {% set ns.gaps = ns.gaps + [{"gap": gap_start ~ " to " ~ gap_end}] %}
                {% endif %}
                {% set ns.last_end = max(ns.last_end, e) %}
              {% endfor %}

              {{ ns.gaps }}
            dispatches_dt: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set ns3 = namespace(members=[]) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set ns3.members = ns3.members + [{
                    "start": as_local(as_datetime(dispatch.start)).isoformat(),
                    "end": as_local(as_datetime(dispatch.end)).isoformat()
                  }] %}
                {% endif %}
              {% endfor %}
              {{ ns3.members }}
            gaps_dt: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set now_t = now() %}
              {% set ns = namespace(intervals=[], gaps=[], last_end=now_t.timestamp()) %}

              {# Build dispatch intervals that are still relevant #}
              {% for d in planned %}
                {% if d.start is not none and d.end is not none and as_datetime(d.end) > now() %}
                  {% set s_dt = as_local(as_datetime(d.start)) %}
                  {% set e_dt = as_local(as_datetime(d.end)) %}
                  {% if e_dt.timestamp() > now_t.timestamp() %}
                    {% set s_ts = max(s_dt.timestamp(), now_t.timestamp()) %}
                    {% set e_ts = e_dt.timestamp() %}
                    {% if e_ts > s_ts %}
                      {% set ns.intervals = ns.intervals + [(s_ts, e_ts)] %}
                    {% endif %}
                  {% endif %}
                {% endif %}
              {% endfor %}

              {% set ns.intervals = ns.intervals | sort(attribute=0) %}

              {# Compute gaps with full datetimes #}
              {% for s, e in ns.intervals %}
                {% if s > ns.last_end %}
                  {% set ns.gaps = ns.gaps + [{
                    "start": (ns.last_end | timestamp_custom("%Y-%m-%dT%H:%M:%S%z", true)),
                    "end": (s | timestamp_custom("%Y-%m-%dT%H:%M:%S%z", true))
                  }] %}
                {% endif %}
                {% set ns.last_end = max(ns.last_end, e) %}
              {% endfor %}

              {{ ns.gaps }}


    ###############################################
    # Remaining Dispatch for this session
    ###############################################
    - sensor:
        - name: "Octopus Intelligent Remaining Dispatch"
          unique_id: octopus_intelligent_remaining_dispatch
          icon: mdi:flash
          unit_of_measurement: "kWh"
          device_class: "energy"
          state_class: total
          state: >
            {{states('input_number.octopus_intelligent_total_dispatch')|float(3) - states('sensor.zappi_charge_added_session')|float(3) }}

    ######################################################
    # Gaps in EV charging Schedule 
    ######################################################
    - sensor:
        - name: "Octopus Next Gap Duration"
          unique_id: octopus_next_gap_duration
          unit_of_measurement: "h"
          icon: mdi:clock-outline
          state: >
            {# ---------- config ---------- #}
            {% set min_gap_hr = 20 / 60 %}
            {% set cutoff_time = "23:30" %}

            {% set now_t = now() %}
            {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}
            {% set cutoff_dt = today_at(cutoff_time) %}

            {# ---- parse solax stop time ---- #}
            {% set solax_raw = states('input_datetime.solax_battery_stop_charge_time') %}
            {% set t_solax = none %}
            {% if solax_raw %}
              {% set try_dt = (as_datetime(solax_raw) if 'T' in solax_raw or solax_raw.count(':') >= 2 else None) %}
              {% if try_dt %}
                {% set t_solax = try_dt %}
              {% else %}
                {% set p = solax_raw.split(':') %}
                {% if p|length >= 2 %}
                  {% set t_solax = today_at("%02d:%02d" | format(p[0]|int, p[1]|int)) + timedelta(days=1) %}
                {% endif %}
              {% endif %}
            {% endif %}

            {# ---- parse Intelligent Target ---- #}
            {% set intel_raw = states('select.octopus_intelligent_target_time') %}
            {% set t_intel = none %}
            {% if intel_raw and ':' in intel_raw %}
              {% set p2 = intel_raw.split(':') %}
              {% if p2|length >= 2 %}
                {% set t_intel = today_at("%02d:%02d" | format(p2[0]|int, p2[1]|int)) + timedelta(days=1) %}
              {% endif %}
            {% endif %}

            {# ---- determine blackout end (stop_dt) ---- #}
            {% if t_intel is none and t_solax is none %}
              {% set stop_dt = cutoff_dt + timedelta(hours=7) %}
            {% elif t_intel is none %}
              {% set stop_dt = t_solax %}
            {% elif t_solax is none %}
              {% set stop_dt = t_intel %}
            {% else %}
              {% set stop_dt = t_intel if t_intel > t_solax else t_solax %}
            {% endif %}

            {% if stop_dt <= cutoff_dt %}
              {% set stop_dt = stop_dt + timedelta(days=1) %}
            {% endif %}

            {% if gaps is not iterable %}
              0
            {% else %}
              {% set ns = namespace(found=None) %}
              {% for gap in gaps %}
                {% set start = as_datetime(gap.start) %}
                {% set end = as_datetime(gap.end) %}

                {% if not start or not end %}
                  {% continue %}
                {% endif %}
                {% if end <= now_t %}
                  {% continue %}
                {% endif %}

                {# --------- FIX: proper clamping instead of skipping ---------- #}

                {# clamp start to now #}
                {% set effective_start = start if start > now_t else now_t %}

                {# clamp end to cutoff #}
                {% set effective_end = end if end < cutoff_dt else cutoff_dt %}

                {# if clamped window vanishes, skip #}
                {% if effective_end <= effective_start %}
                  {% continue %}
                {% endif %}

                {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                {% if dur_hr >= min_gap_hr %}
                  {% set ns.found = dur_hr %}
                  {% break %}
                {% endif %}
              {% endfor %}

              {{ ns.found | round(2) if ns.found is not none else 0 }}
            {% endif %}

          attributes:
            next_gap_start: >
              {% set min_gap_hr = 20 / 60 %}
              {% set now_t = now() %}
              {% set cutoff = today_at("23:30") %}
              {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}

              {# rebuild blackout window #}
              {% set solax_raw = states('input_datetime.solax_battery_stop_charge_time') %}
              {% set t_solax = none %}
              {% if solax_raw %}
                {% set try_dt = (as_datetime(solax_raw) if 'T' in solax_raw or solax_raw.count(':') >= 2 else None) %}
                {% if try_dt %}
                  {% set t_solax = try_dt %}
                {% else %}
                  {% set p = solax_raw.split(':') %}
                  {% if p|length >= 2 %}
                    {% set t_solax = today_at("%02d:%02d" | format(p[0]|int, p[1]|int)) + timedelta(days=1) %}
                  {% endif %}
                {% endif %}
              {% endif %}

              {% set intel_raw = states('select.octopus_intelligent_target_time') %}
              {% set t_intel = none %}
              {% if intel_raw and ':' in intel_raw %}
                {% set p2 = intel_raw.split(':') %}
                {% if p2|length >= 2 %}
                  {% set t_intel = today_at("%02d:%02d" | format(p2[0]|int, p2[1]|int)) + timedelta(days=1) %}
                {% endif %}
              {% endif %}

              {% if t_intel is none and t_solax is none %}
                {% set stop_dt = cutoff + timedelta(hours=7) %}
              {% elif t_intel is none %}
                {% set stop_dt = t_solax %}
              {% elif t_solax is none %}
                {% set stop_dt = t_intel %}
              {% else %}
                {% set stop_dt = t_intel if t_intel > t_solax else t_solax %}
              {% endif %}
              {% if stop_dt <= cutoff %}
                {% set stop_dt = stop_dt + timedelta(days=1) %}
              {% endif %}

              {% if gaps is not iterable %}
              {% else %}
                {% set ns = namespace(start=None) %}
                {% for gap in gaps %}
                  {% set start = as_datetime(gap.start) %}
                  {% set end = as_datetime(gap.end) %}
                  {% if not start or not end %}{% continue %}{% endif %}
                  {% if end <= now_t %}{% continue %}{% endif %}

                  {# FIX: clamping (same as main state) #}
                  {% set effective_start = start if start > now_t else now_t %}
                  {% set effective_end = end if end < cutoff else cutoff %}
                  {% if effective_end <= effective_start %}{% continue %}{% endif %}

                  {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                  {% if dur_hr >= min_gap_hr %}
                    {% set ns.start = effective_start.isoformat() %}
                    {% break %}
                  {% endif %}
                {% endfor %}
                {{ ns.start or '' }}
              {% endif %}

            next_gap_end: >
              {% set min_gap_hr = 20 / 60 %}
              {% set now_t = now() %}
              {% set cutoff = today_at("23:30") %}
              {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}

              {# same blackout window rebuild as above #}
              {% set solax_raw = states('input_datetime.solax_battery_stop_charge_time') %}
              {% set t_solax = none %}
              {% if solax_raw %}
                {% set try_dt = (as_datetime(solax_raw) if 'T' in solax_raw or solax_raw.count(':') >= 2 else None) %}
                {% if try_dt %}
                  {% set t_solax = try_dt %}
                {% else %}
                  {% set p = solax_raw.split(':') %}
                  {% if p|length >= 2 %}
                    {% set t_solax = today_at("%02d:%02d" | format(p[0]|int, p[1]|int)) + timedelta(days=1) %}
                  {% endif %}
                {% endif %}
              {% endif %}

              {% set intel_raw = states('select.octopus_intelligent_target_time') %}
              {% set t_intel = none %}
              {% if intel_raw and ':' in intel_raw %}
                {% set p2 = intel_raw.split(':') %}
                {% if p2|length >= 2 %}
                  {% set t_intel = today_at("%02d:%02d" | format(p2[0]|int, p2[1]|int)) + timedelta(days=1) %}
                {% endif %}
              {% endif %}

              {% if t_intel is none and t_solax is none %}
                {% set stop_dt = cutoff + timedelta(hours=7) %}
              {% elif t_intel is none %}
                {% set stop_dt = t_solax %}
              {% elif t_solax is none %}
                {% set stop_dt = t_intel %}
              {% else %}
                {% set stop_dt = t_intel if t_intel > t_solax else t_solax %}
              {% endif %}
              {% if stop_dt <= cutoff %}
                {% set stop_dt = stop_dt + timedelta(days=1) %}
              {% endif %}

              {% if gaps is not iterable %}
              {% else %}
                {% set ns = namespace(end=None) %}
                {% for gap in gaps %}
                  {% set start = as_datetime(gap.start) %}
                  {% set end = as_datetime(gap.end) %}
                  {% if not start or not end %}{% continue %}{% endif %}
                  {% if end <= now_t %}{% continue %}{% endif %}

                  {# FIX: clamping #}
                  {% set effective_start = start if start > now_t else now_t %}
                  {% set effective_end = end if end < cutoff else cutoff %}
                  {% if effective_end <= effective_start %}{% continue %}{% endif %}

                  {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                  {% if dur_hr >= min_gap_hr %}
                    {% set ns.end = effective_end.isoformat() %}
                    {% break %}
                  {% endif %}
                {% endfor %}
                {{ ns.end or '' }}
              {% endif %}




    # - sensor:
    #     - name: "Octopus Next Gap Duration"
    #       unique_id: octopus_next_gap_duration
    #       unit_of_measurement: "h"
    #       icon: mdi:clock-outline
    #       state: >
    #         {% set min_gap_hr = 20 / 60 %}
    #         {% set now_t = now() %}
    #         {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}

    #         {# --- Cutoff time --- #}
    #         {% set cut_off = '23:30'.split(':') %}
    #         {% set cut_offm = cut_off[0]|int * 60 + cut_off[1]|int %}
    #         {% set nowm = now().hour * 60 + now().minute %}

    #         {# --- Stop times in minutes --- #}
    #         {% set stop1_raw = states('input_datetime.solax_battery_stop_charge_time')[:5].split(':') %}
    #         {% set stop1m = stop1_raw[0]|int * 60 + stop1_raw[1]|int %}
    #         {% set intel_raw = states('select.octopus_intelligent_target_time') %}
    #         {% if intel_raw is string and ':' in intel_raw %}
    #           {% set intel_raw = intel_raw ~ ':00' %}  {# ensures HH:MM:SS format #}
    #           {% set intel_parts = intel_raw.split(':') %}
    #           {% set intelm = intel_parts[0]|int * 60 + intel_parts[1]|int %}
    #         {% else %}
    #           {% set intelm = stop1m %}
    #         {% endif %}

    #         {# Later of the two stop times #}
    #         {% set stopm = stop1m if stop1m > intelm else intelm %}

    #         {# --- In cutoff window (handles crossing midnight) --- #}
    #         {% set in_cut_off = (
    #             (cut_offm <= stopm and cut_offm <= nowm <= stopm)
    #             or
    #             (cut_offm > stopm and (nowm >= cut_offm or nowm <= stopm))
    #         ) %}

    #         {# --- Gap calculation --- #}
    #         {% if in_cut_off or not gaps %}
    #           0
    #         {% else %}
    #           {% set ns = namespace(found=None) %}
    #           {% for gap in gaps %}
    #             {% set start = as_datetime(gap.start) %}
    #             {% set end   = as_datetime(gap.end) %}
    #             {% if not start or not end or end <= now_t %}
    #               {% continue %}
    #             {% endif %}
    #             {% set effective_start = start if start > now_t else now_t %}
    #             {% set dur_hr = (end - effective_start).total_seconds() / 3600 %}
    #             {% if dur_hr >= min_gap_hr %}
    #               {% set ns.found = dur_hr %}
    #               {% break %}
    #             {% endif %}
    #           {% endfor %}
    #           {{ ns.found | round(2) if ns.found is not none else None }}
    #         {% endif %}

    #       attributes:
    #         next_gap_start: >
    #           {% set min_gap_hr = 20 / 60 %}
    #           {% set now_t = now() %}
    #           {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}

    #           {% set cut_off = '23:30'.split(':') %}
    #           {% set cut_offm = cut_off[0]|int * 60 + cut_off[1]|int %}
    #           {% set nowm = now().hour * 60 + now().minute %}

    #           {% set stop1_raw = states('input_datetime.solax_battery_stop_charge_time')[:5].split(':') %}
    #           {% set stop1m = stop1_raw[0]|int * 60 + stop1_raw[1]|int %}
    #           {% set intel_raw = states('select.octopus_intelligent_target_time') %}
    #           {% if intel_raw is string and ':' in intel_raw %}
    #             {% set intel_raw = intel_raw ~ ':00' %}  {# ensures HH:MM:SS format #}
    #             {% set intel_parts = intel_raw.split(':') %}
    #             {% set intelm = intel_parts[0]|int * 60 + intel_parts[1]|int %}
    #           {% else %}
    #             {% set intelm = stop1m %}
    #           {% endif %}
    #           {% set stopm = stop1m if stop1m > intelm else intelm %}

    #           {% set in_cut_off = (
    #               (cut_offm <= stopm and cut_offm <= nowm <= stopm)
    #               or
    #               (cut_offm > stopm and (nowm >= cut_offm or nowm <= stopm))
    #           ) %}

    #           {% if in_cut_off or not gaps %}
                
    #           {% else %}
    #             {% set ns = namespace(start=None) %}
    #             {% for gap in gaps %}
    #               {% set start = as_datetime(gap.start) %}
    #               {% set end   = as_datetime(gap.end) %}
    #               {% if not start or not end or end <= now_t %}
    #                 {% continue %}
    #               {% endif %}
    #               {% set effective_start = start if start > now_t else now_t %}
    #               {% set dur_hr = (end - effective_start).total_seconds() / 3600 %}
    #               {% if dur_hr >= min_gap_hr %}
    #                 {% set ns.start = effective_start.isoformat() %}
    #                 {% break %}
    #               {% endif %}
    #             {% endfor %}
    #             {{ ns.start or ''}}
    #           {% endif %}

    #         next_gap_end: >
    #           {% set min_gap_hr = 20 / 60 %}
    #           {% set now_t = now() %}
    #           {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}

    #           {% set cut_off = '23:30'.split(':') %}
    #           {% set cut_offm = cut_off[0]|int * 60 + cut_off[1]|int %}
    #           {% set nowm = now().hour * 60 + now().minute %}

    #           {% set stop1_raw = states('input_datetime.solax_battery_stop_charge_time')[:5].split(':') %}
    #           {% set stop1m = stop1_raw[0]|int * 60 + stop1_raw[1]|int %}
    #           {% set intel_raw = states('select.octopus_intelligent_target_time') %}
    #           {% if intel_raw is string and ':' in intel_raw %}
    #             {% set intel_raw = intel_raw ~ ':00' %}  {# ensures HH:MM:SS format #}
    #             {% set intel_parts = intel_raw.split(':') %}
    #             {% set intelm = intel_parts[0]|int * 60 + intel_parts[1]|int %}
    #           {% else %}
    #             {% set intelm = stop1m %}
    #           {% endif %}
    #           {% set stopm = stop1m if stop1m > intelm else intelm %}

    #           {% set in_cut_off = (
    #               (cut_offm <= stopm and cut_offm <= nowm <= stopm)
    #               or
    #               (cut_offm > stopm and (nowm >= cut_offm or nowm <= stopm))
    #           ) %}

    #           {% if in_cut_off or not gaps %}
                
    #           {% else %}
    #             {% set ns = namespace(end=None) %}
    #             {% for gap in gaps %}
    #               {% set start = as_datetime(gap.start) %}
    #               {% set end   = as_datetime(gap.end) %}
    #               {% if not start or not end or end <= now_t %}
    #                 {% continue %}
    #               {% endif %}
    #               {% set effective_start = start if start > now_t else now_t %}
    #               {% set dur_hr = (end - effective_start).total_seconds() / 3600 %}
    #               {% if dur_hr >= min_gap_hr %}
    #                 {% set ns.end = end.isoformat() %}
    #                 {% break %}
    #               {% endif %}
    #             {% endfor %}
    #             {{ ns.end or ''}}
    #           {% endif %}


    ######################################################
    # Hours of charge required
    ######################################################    
    - sensor:
      - name:  Calculated EV Charge Start Time
        unique_id: calculated_ev_charge_start_time
        device_class: "timestamp"
        icon: mdi:clock-alert
        state: >
          {% set td = timedelta(days=10) %}
          {% set target_time = states('sensor.octopus_intelligent_target_time') %}
          {% set battery_size = states('input_number.ev_battery_size')|float(0) %}
          {% set charge_pct = states('number.octopus_intelligent_charge_target')|int(100) %}
          {% set seconds = (charge_pct/100 * battery_size / 6.8 * 3600) | int %}
          {% set start = target_time | as_timestamp | int - seconds if target_time not in ['unknown','unavailable',''] else none %}
          {% set eleventhirty = (target_time | as_datetime if target_time not in ['unknown','unavailable',''] else now()).date() | as_timestamp - 1800 %}
          {% if start is not none %}
            {% set dt = (start if start < eleventhirty else eleventhirty) | as_datetime |as_local%}
          {% else %}
            {% set dt = none %}
          {% endif %}
          {{ dt.isoformat() if dt else (now() + td).isoformat() }}