########################################
# v9.3.0 Hardening. Unfortunately this minor change will result in 0 spikes butwill result in less messy logs
#.       The main hardening was done in the renameing entities templates yaml so that we reduce the amount of 
#.       unnecessary triggering of the house keeping automation when the octopus api stops responding.
# v9.0.0 Added completed dispatches for current session
# v8.0.1 Additional attribute in octopus_total_planned_dispatch.dispatches_kwh to support dashboard
# v8.0.0 Refactor/Clean up and improved Gap logic
# v1.0.1 Remove old dispatched items
# Template to agragate the total of the dispatches
########################################
octopus_dispatches_template_octopus_dispatch:
  template:
    ######################################################
    # Octopus dispatch kWh
    ######################################################
    - sensor:
        - name: "Octopus Total Planned Dispatch"
          unique_id: octopus_total_planned_dispatch
          icon: mdi:ev-station
          unit_of_measurement: "kWh"
          device_class: energy
          state_class: total
          state: >
            {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching', 'planned_dispatches') %}
            {% set disconnected_raw = states('sensor.zappi_last_disconnected') %}
            {% set connected_raw = states('sensor.zappi_last_connected') %}

            {% set disconnected = (
              disconnected_raw
              if disconnected_raw not in ['unknown', 'unavailable', '']
              else '1970-01-01 00:00:00'
            ) | as_datetime | as_local %}

            {% set connected = (
              connected_raw
              if connected_raw not in ['unknown', 'unavailable', '']
              else '1970-01-01 00:00:00'
            ) | as_datetime | as_local %}
            
            {# --- CASE 1: Data unavailable -> return last state --- #}
            {% if planned is none or planned in ['unknown', 'unavailable'] %}
              {{ states('sensor.octopus_total_planned_dispatch')|float(0) }}
            
            {# --- CASE 2: Data available but empty -> return last state --- #}
            {% elif planned == [] %}
              {% if disconnected > connected %}
                {{0}}
              {% else %}
                {{ states('sensor.octopus_total_planned_dispatch') | float(0) }}
              {% endif %}
            {# --- CASE 3: Calculate remaining dispatch --- #}
            {% else %}
              {% set ns2 = namespace(total_dispatch=0.0) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set ns2.total_dispatch = ns2.total_dispatch + ((dispatch.charge_in_kwh | float(0)) * -1) %}
                {% endif %}
              {% endfor %}
              {{ 0 if ns2.total_dispatch < 1 else ns2.total_dispatch }}
            {% endif %}


          attributes:
            total_dispatches: >
              {{ (state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or []) | count }}

            dispatches: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set ns3 = namespace(members=[]) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set ns3.members = ns3.members + [{
                    "dispatch": (dispatch.start|as_datetime|as_local).strftime('%H:%M') 
                              ~ " to " 
                              ~ (dispatch.end|as_datetime|as_local).strftime('%H:%M')
                  }] %}
                {% endif %}
              {% endfor %}
              {{ ns3.members }}

            gaps: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set now_t = now() %}
              {% set ns = namespace(intervals=[], gaps=[], last_end=now_t.timestamp()) %}

              {# --- Collect all valid dispatch intervals --- #}
              {% for d in planned %}
                {% if d.start is not none and d.end is not none and as_datetime(d.end) > now() %}
                  {% set s_dt = as_local(as_datetime(d.start)) %}
                  {% set e_dt = as_local(as_datetime(d.end)) %}
                  {% if e_dt > now_t %}
                    {% set s_ts = max(s_dt.timestamp(), now_t.timestamp()) %}
                    {% set e_ts = e_dt.timestamp() %}
                    {% if e_ts > s_ts %}
                      {% set ns.intervals = ns.intervals + [(s_ts, e_ts)] %}
                    {% endif %}
                  {% endif %}
                {% endif %}
              {% endfor %}

              {# --- Sort intervals by start time --- #}
              {% set ns.intervals = ns.intervals | sort(attribute=0) %}

              {# --- Compute gaps between intervals --- #}
              {% for s, e in ns.intervals %}
                {% if s > ns.last_end %}
                  {% set gap_start = ns.last_end | timestamp_custom("%H:%M", true) %}
                  {% set gap_end = s | timestamp_custom("%H:%M", true) %}
                  {% set ns.gaps = ns.gaps + [{"gap": gap_start ~ " to " ~ gap_end}] %}
                {% endif %}
                {% set ns.last_end = max(ns.last_end, e) %}
              {% endfor %}

              {{ ns.gaps }}
            dispatches_dt: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set ns3 = namespace(members=[]) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set ns3.members = ns3.members + [{
                    "start": as_local(as_datetime(dispatch.start)).isoformat(),
                    "end": as_local(as_datetime(dispatch.end)).isoformat()
                  }] %}
                {% endif %}
              {% endfor %}
              {{ ns3.members }}
            gaps_dt: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set now_t = now() %}
              {% set ns = namespace(intervals=[], gaps=[], last_end=now_t.timestamp()) %}

              {# Build dispatch intervals that are still relevant #}
              {% for d in planned %}
                {% if d.start is not none and d.end is not none and as_datetime(d.end) > now() %}
                  {% set s_dt = as_local(as_datetime(d.start)) %}
                  {% set e_dt = as_local(as_datetime(d.end)) %}
                  {% if e_dt.timestamp() > now_t.timestamp() %}
                    {% set s_ts = max(s_dt.timestamp(), now_t.timestamp()) %}
                    {% set e_ts = e_dt.timestamp() %}
                    {% if e_ts > s_ts %}
                      {% set ns.intervals = ns.intervals + [(s_ts, e_ts)] %}
                    {% endif %}
                  {% endif %}
                {% endif %}
              {% endfor %}

              {% set ns.intervals = ns.intervals | sort(attribute=0) %}

              {# Compute gaps with full datetimes #}
              {% for s, e in ns.intervals %}
                {% if s > ns.last_end %}
                  {% set ns.gaps = ns.gaps + [{
                    "start": (ns.last_end | timestamp_custom("%Y-%m-%dT%H:%M:%S%z", true)),
                    "end": (s | timestamp_custom("%Y-%m-%dT%H:%M:%S%z", true))
                  }] %}
                {% endif %}
                {% set ns.last_end = max(ns.last_end, e) %}
              {% endfor %}

              {{ ns.gaps }}
            dispatches_kwh: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set ns4 = namespace(members=[]) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set start = as_local(as_datetime(dispatch.start)).strftime('%H:%M') %}
                  {% set end   = as_local(as_datetime(dispatch.end)).strftime('%H:%M') %}
                  {% set kwh   = (dispatch.charge_in_kwh | float(0)) %}
                  {% set ns4.members = ns4.members + [{
                    "dispatch": start ~ " to " ~ end ~ " " ~ (kwh | round(2)) ~ " kWh"
                  }] %}
                {% endif %}
              {% endfor %}
              {{ ns4.members }}

    ###############################################
    # Remaining Dispatch for this session
    ###############################################
    - trigger:
        - platform: state
          entity_id:
            - input_number.octopus_intelligent_total_dispatch
            - sensor.zappi_charge_added_session

      sensor:
        - name: "Remaining Dispatch"
          unique_id: octopus_intelligent_remaining_dispatch
          icon: mdi:flash
          unit_of_measurement: "kWh"
          device_class: energy
          state_class: measurement
          state: >
            {% set total = states('input_number.octopus_intelligent_total_dispatch') %}
            {% set session = states('sensor.zappi_charge_added_session') %}
            {% set prev = this.state %}

            {# If either input is invalid, use previous state or 0 #}
            {% if total in ['unknown','unavailable','',none] or session in ['unknown','unavailable','',none] %}
              {% if prev not in ['unknown','unavailable','',none] %}
                {{ prev }}
              {% else %}
                0
              {% endif %}
            {% else %}
              {% set total_f = total | float %}
              {% set session_f = session | float %}
              {{ max(total_f - session_f, 0) | round(3) }}
            {% endif %}



    ######################################################
    # Gaps in EV charging Schedule 
    ######################################################
    - sensor:
        - name: "Octopus Next Gap Duration"
          unique_id: octopus_next_gap_duration
          unit_of_measurement: "h"
          icon: mdi:clock-outline
          state: >
            {# ---------- config ---------- #}
            {% set min_gap_hr = 20 / 60 %}
            {% set cutoff_time = "23:30" %}

            {% set now_t = now() %}
            {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}
            {% set cutoff_dt = today_at(cutoff_time) %}

            {# ---- parse solax stop time ---- #}
            {% set solax_raw = states('input_datetime.solax_battery_stop_charge_time') %}
            {% set t_solax = none %}
            {% if solax_raw %}
              {% set try_dt = (as_datetime(solax_raw) if 'T' in solax_raw or solax_raw.count(':') >= 2 else None) %}
              {% if try_dt %}
                {% set t_solax = try_dt %}
              {% else %}
                {% set p = solax_raw.split(':') %}
                {% if p|length >= 2 %}
                  {% set t_solax = today_at("%02d:%02d" | format(p[0]|int, p[1]|int)) + timedelta(days=1) %}
                {% endif %}
              {% endif %}
            {% endif %}

            {# ---- parse Intelligent Target ---- #}
            {% set intel_raw = states('select.octopus_intelligent_target_time') %}
            {% set t_intel = none %}
            {% if intel_raw and ':' in intel_raw %}
              {% set p2 = intel_raw.split(':') %}
              {% if p2|length >= 2 %}
                {% set t_intel = today_at("%02d:%02d" | format(p2[0]|int, p2[1]|int)) + timedelta(days=1) %}
              {% endif %}
            {% endif %}

            {# ---- determine blackout end (stop_dt) ---- #}
            {% if t_intel is none and t_solax is none %}
              {% set stop_dt = cutoff_dt + timedelta(hours=7) %}
            {% elif t_intel is none %}
              {% set stop_dt = t_solax %}
            {% elif t_solax is none %}
              {% set stop_dt = t_intel %}
            {% else %}
              {% set stop_dt = t_intel if t_intel > t_solax else t_solax %}
            {% endif %}

            {% if stop_dt <= cutoff_dt %}
              {% set stop_dt = stop_dt + timedelta(days=1) %}
            {% endif %}

            {% if gaps is not iterable %}
              0
            {% else %}
              {% set ns = namespace(found=None) %}
              {% for gap in gaps %}
                {% set start = as_datetime(gap.start) %}
                {% set end = as_datetime(gap.end) %}

                {% if not start or not end %}
                  {% continue %}
                {% endif %}
                {% if end <= now_t %}
                  {% continue %}
                {% endif %}

                {# --------- FIX: proper clamping instead of skipping ---------- #}

                {# clamp start to now #}
                {% set effective_start = start if start > now_t else now_t %}

                {# clamp end to cutoff #}
                {% set effective_end = end if end < cutoff_dt else cutoff_dt %}

                {# if clamped window vanishes, skip #}
                {% if effective_end <= effective_start %}
                  {% continue %}
                {% endif %}

                {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                {% if dur_hr >= min_gap_hr %}
                  {% set ns.found = dur_hr %}
                  {% break %}
                {% endif %}
              {% endfor %}

              {{ ns.found | round(2) if ns.found is not none else 0 }}
            {% endif %}

          attributes:
            next_gap_start: >
              {% set min_gap_hr = 20 / 60 %}
              {% set now_t = now() %}
              {% set cutoff = today_at("23:30") %}
              {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}

              {# rebuild blackout window #}
              {% set solax_raw = states('input_datetime.solax_battery_stop_charge_time') %}
              {% set t_solax = none %}
              {% if solax_raw %}
                {% set try_dt = (as_datetime(solax_raw) if 'T' in solax_raw or solax_raw.count(':') >= 2 else None) %}
                {% if try_dt %}
                  {% set t_solax = try_dt %}
                {% else %}
                  {% set p = solax_raw.split(':') %}
                  {% if p|length >= 2 %}
                    {% set t_solax = today_at("%02d:%02d" | format(p[0]|int, p[1]|int)) + timedelta(days=1) %}
                  {% endif %}
                {% endif %}
              {% endif %}

              {% set intel_raw = states('select.octopus_intelligent_target_time') %}
              {% set t_intel = none %}
              {% if intel_raw and ':' in intel_raw %}
                {% set p2 = intel_raw.split(':') %}
                {% if p2|length >= 2 %}
                  {% set t_intel = today_at("%02d:%02d" | format(p2[0]|int, p2[1]|int)) + timedelta(days=1) %}
                {% endif %}
              {% endif %}

              {% if t_intel is none and t_solax is none %}
                {% set stop_dt = cutoff + timedelta(hours=7) %}
              {% elif t_intel is none %}
                {% set stop_dt = t_solax %}
              {% elif t_solax is none %}
                {% set stop_dt = t_intel %}
              {% else %}
                {% set stop_dt = t_intel if t_intel > t_solax else t_solax %}
              {% endif %}
              {% if stop_dt <= cutoff %}
                {% set stop_dt = stop_dt + timedelta(days=1) %}
              {% endif %}

              {% if gaps is not iterable %}
              {% else %}
                {% set ns = namespace(start=None) %}
                {% for gap in gaps %}
                  {% set start = as_datetime(gap.start) %}
                  {% set end = as_datetime(gap.end) %}
                  {% if not start or not end %}{% continue %}{% endif %}
                  {% if end <= now_t %}{% continue %}{% endif %}

                  {# FIX: clamping (same as main state) #}
                  {% set effective_start = start if start > now_t else now_t %}
                  {% set effective_end = end if end < cutoff else cutoff %}
                  {% if effective_end <= effective_start %}{% continue %}{% endif %}

                  {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                  {% if dur_hr >= min_gap_hr %}
                    {% set ns.start = effective_start.isoformat() %}
                    {% break %}
                  {% endif %}
                {% endfor %}
                {{ ns.start or '' }}
              {% endif %}

            next_gap_end: >
              {% set min_gap_hr = 20 / 60 %}
              {% set now_t = now() %}
              {% set cutoff = today_at("23:30") %}
              {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}

              {# same blackout window rebuild as above #}
              {% set solax_raw = states('input_datetime.solax_battery_stop_charge_time') %}
              {% set t_solax = none %}
              {% if solax_raw %}
                {% set try_dt = (as_datetime(solax_raw) if 'T' in solax_raw or solax_raw.count(':') >= 2 else None) %}
                {% if try_dt %}
                  {% set t_solax = try_dt %}
                {% else %}
                  {% set p = solax_raw.split(':') %}
                  {% if p|length >= 2 %}
                    {% set t_solax = today_at("%02d:%02d" | format(p[0]|int, p[1]|int)) + timedelta(days=1) %}
                  {% endif %}
                {% endif %}
              {% endif %}

              {% set intel_raw = states('select.octopus_intelligent_target_time') %}
              {% set t_intel = none %}
              {% if intel_raw and ':' in intel_raw %}
                {% set p2 = intel_raw.split(':') %}
                {% if p2|length >= 2 %}
                  {% set t_intel = today_at("%02d:%02d" | format(p2[0]|int, p2[1]|int)) + timedelta(days=1) %}
                {% endif %}
              {% endif %}

              {% if t_intel is none and t_solax is none %}
                {% set stop_dt = cutoff + timedelta(hours=7) %}
              {% elif t_intel is none %}
                {% set stop_dt = t_solax %}
              {% elif t_solax is none %}
                {% set stop_dt = t_intel %}
              {% else %}
                {% set stop_dt = t_intel if t_intel > t_solax else t_solax %}
              {% endif %}
              {% if stop_dt <= cutoff %}
                {% set stop_dt = stop_dt + timedelta(days=1) %}
              {% endif %}

              {% if gaps is not iterable %}
              {% else %}
                {% set ns = namespace(end=None) %}
                {% for gap in gaps %}
                  {% set start = as_datetime(gap.start) %}
                  {% set end = as_datetime(gap.end) %}
                  {% if not start or not end %}{% continue %}{% endif %}
                  {% if end <= now_t %}{% continue %}{% endif %}

                  {# FIX: clamping #}
                  {% set effective_start = start if start > now_t else now_t %}
                  {% set effective_end = end if end < cutoff else cutoff %}
                  {% if effective_end <= effective_start %}{% continue %}{% endif %}

                  {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                  {% if dur_hr >= min_gap_hr %}
                    {% set ns.end = effective_end.isoformat() %}
                    {% break %}
                  {% endif %}
                {% endfor %}
                {{ ns.end or '' }}
              {% endif %}


    - sensor:
        - name: "Octopus Total Completed Dispatch"
          unique_id: octopus_total_completed_dispatch
          icon: mdi:ev-station
          unit_of_measurement: "kWh"
          device_class: energy
          state_class: total

          state: >
            {% set completed = state_attr('binary_sensor.octopus_intelligent_dispatching', 'completed_dispatches') or [] %}
            {% set last_dt_raw = states('input_datetime.zappi_last_connected') | default('') %}
            {% set last_dt = last_dt_raw | as_datetime %}
            {% if last_dt is none %}
              {{ none }}
            {% else %}
              {% set last_dt = last_dt | as_local %}
              {% set ns = namespace(total=0.0) %}
              {% for dispatch in completed %}
                {% set start_dt = dispatch.start | as_datetime %}
                {% set end_dt   = dispatch.end   | as_datetime %}
                {% if start_dt is not none and end_dt is not none %}
                  {% set start_dt = start_dt | as_local %}
                  {% set end_dt   = end_dt   | as_local %}
                  {% if start_dt > last_dt and end_dt > last_dt %}
                    {% set ns.total = ns.total + (dispatch.charge_in_kwh | float(0) * -1) %}
                  {% endif %}
                {% endif %}
              {% endfor %}
              {{ 0 if ns.total < 0.5 else ns.total }}
            {% endif %}

          attributes:
            completed_total_dispatches: >
              {% set completed = state_attr('binary_sensor.octopus_intelligent_dispatching', 'completed_dispatches') or [] %}
              {% set last_dt = states('input_datetime.zappi_last_connected') | as_datetime %}
              {% if last_dt is none %}
                0
              {% else %}
                {% set last_dt = last_dt | as_local %}
                {% set ns = namespace(count=0) %}
                {% for dispatch in completed %}
                  {% set start_dt = dispatch.start | as_datetime %}
                  {% set end_dt   = dispatch.end   | as_datetime %}
                  {% if start_dt is not none and end_dt is not none %}
                    {% set start_dt = start_dt | as_local %}
                    {% set end_dt   = end_dt   | as_local %}
                    {% if start_dt > last_dt and end_dt > last_dt %}
                      {% set ns.count = ns.count + 1 %}
                    {% endif %}
                  {% endif %}
                {% endfor %}
                {{ ns.count }}
              {% endif %}

            completed_dispatches: >
              {% set completed = state_attr('binary_sensor.octopus_intelligent_dispatching', 'completed_dispatches') or [] %}
              {% set last_dt = states('input_datetime.zappi_last_connected') | as_datetime %}
              {% if last_dt is none %}
                []
              {% else %}
                {% set last_dt = last_dt | as_local %}
                {% set ns = namespace(members=[]) %}
                {% for dispatch in completed %}
                  {% set start_dt = dispatch.start | as_datetime %}
                  {% set end_dt   = dispatch.end   | as_datetime %}
                  {% if start_dt is not none and end_dt is not none %}
                    {% set start_dt = start_dt | as_local %}
                    {% set end_dt   = end_dt   | as_local %}
                    {% if start_dt > last_dt and end_dt > last_dt %}
                      {% set ns.members = ns.members + [{
                        "dispatch": start_dt.strftime('%H:%M') ~ " to " ~ end_dt.strftime('%H:%M')
                      }] %}
                    {% endif %}
                  {% endif %}
                {% endfor %}
                {{ ns.members }}
              {% endif %}

            completed_dispatches_dt: >
              {% set completed = state_attr('binary_sensor.octopus_intelligent_dispatching', 'completed_dispatches') or [] %}
              {% set last_dt = states('input_datetime.zappi_last_connected') | as_datetime %}
              {% if last_dt is none %}
                []
              {% else %}
                {% set last_dt = last_dt | as_local %}
                {% set ns = namespace(members=[]) %}
                {% for dispatch in completed %}
                  {% set start_dt = dispatch.start | as_datetime %}
                  {% set end_dt   = dispatch.end   | as_datetime %}
                  {% if start_dt is not none and end_dt is not none %}
                    {% set start_dt = start_dt | as_local %}
                    {% set end_dt   = end_dt   | as_local %}
                    {% if start_dt > last_dt and end_dt > last_dt %}
                      {% set ns.members = ns.members + [{
                        "start": start_dt.isoformat(),
                        "end":   end_dt.isoformat()
                      }] %}
                    {% endif %}
                  {% endif %}
                {% endfor %}
                {{ ns.members }}
              {% endif %}

            completed_dispatches_kwh: >
              {% set completed = state_attr('binary_sensor.octopus_intelligent_dispatching', 'completed_dispatches') or [] %}
              {% set last_dt = states('input_datetime.zappi_last_connected') | as_datetime %}
              {% if last_dt is none %}
                []
              {% else %}
                {% set last_dt = last_dt | as_local %}
                {% set ns = namespace(members=[]) %}
                {% for dispatch in completed %}
                  {% set start_dt = dispatch.start | as_datetime %}
                  {% set end_dt   = dispatch.end   | as_datetime %}
                  {% set kwh = dispatch.charge_in_kwh | float(0) %}
                  {% if start_dt is not none and end_dt is not none %}
                    {% set start_dt = start_dt | as_local %}
                    {% set end_dt   = end_dt   | as_local %}
                    {% if start_dt > last_dt and end_dt > last_dt %}
                      {% set ns.members = ns.members + [{
                        "dispatch": start_dt.strftime('%H:%M') ~ " to " ~ end_dt.strftime('%H:%M') ~ " " ~ (kwh | round(2)) ~ " kWh"
                      }] %}
                    {% endif %}
                  {% endif %}
                {% endfor %}
                {{ ns.members }}
              {% endif %}
