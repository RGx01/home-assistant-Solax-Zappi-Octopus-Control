########################################
# v1.0.1 Remove old dispatched items
# Template to agragate the total of the dispatches
########################################
octopus_dispatches_template_octopus_dispatch:
  template:
    ######################################################
    # Generate an event when theres a new dispatch
    ######################################################
    - trigger:
        - trigger: state
          entity_id: sensor.octopus_total_planned_dispatch
          from: "0"
          not_to:
            - unavailable
      action:
        - event: Solax Zappi Octopus Control
          event_data:
            message: >-
              Octopus Planned Dispatch @
              {{now().strftime('%H:%M')}}. 
              {{states('sensor.octopus_total_planned_dispatch')}}kWh.
            title: Octopus Dispatch
            class: normal
    ######################################################
    # Octopus dispatch kWh
    ######################################################
    - sensor:
        - name: "Octopus Total Planned Dispatch"
          unique_id: octopus_total_planned_dispatch
          icon: mdi:ev-station
          unit_of_measurement: "kWh"
          device_class: energy
          state_class: total
          state: >
            {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching', 'planned_dispatches') or [] %}
            {% set ns2 = namespace(total_dispatch=0.0) %}
            {% for dispatch in planned %}
              {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                {% set ns2.total_dispatch = ns2.total_dispatch + ((dispatch.end|as_timestamp - dispatch.start|as_timestamp)/3600*6.9) %}
              {% endif %}
            {% endfor %}
            {{ ns2.total_dispatch }}

          attributes:
            total_dispatches: >
              {{ (state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or []) | count }}

            dispatches: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set ns3 = namespace(members=[]) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set ns3.members = ns3.members + [{
                    "dispatch": (dispatch.start|as_datetime|as_local).strftime('%H:%M') 
                              ~ " to " 
                              ~ (dispatch.end|as_datetime|as_local).strftime('%H:%M')
                  }] %}
                {% endif %}
              {% endfor %}
              {{ ns3.members }}

            gaps: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set now_t = now() %}
              {% set ns = namespace(intervals=[], gaps=[], last_end=now_t.timestamp()) %}

              {# --- Collect all valid dispatch intervals --- #}
              {% for d in planned %}
                {% if d.start is not none and d.end is not none and as_datetime(d.end) > now() %}
                  {% set s_dt = as_local(as_datetime(d.start)) %}
                  {% set e_dt = as_local(as_datetime(d.end)) %}
                  {% if e_dt > now_t %}
                    {% set s_ts = max(s_dt.timestamp(), now_t.timestamp()) %}
                    {% set e_ts = e_dt.timestamp() %}
                    {% if e_ts > s_ts %}
                      {% set ns.intervals = ns.intervals + [(s_ts, e_ts)] %}
                    {% endif %}
                  {% endif %}
                {% endif %}
              {% endfor %}

              {# --- Sort intervals by start time --- #}
              {% set ns.intervals = ns.intervals | sort(attribute=0) %}

              {# --- Compute gaps between intervals --- #}
              {% for s, e in ns.intervals %}
                {% if s > ns.last_end %}
                  {% set gap_start = ns.last_end | timestamp_custom("%H:%M", true) %}
                  {% set gap_end = s | timestamp_custom("%H:%M", true) %}
                  {% set ns.gaps = ns.gaps + [{"gap": gap_start ~ " to " ~ gap_end}] %}
                {% endif %}
                {% set ns.last_end = max(ns.last_end, e) %}
              {% endfor %}

              {{ ns.gaps }}
            dispatches_dt: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set ns3 = namespace(members=[]) %}
              {% for dispatch in planned %}
                {% if dispatch.start is not none and dispatch.end is not none and as_datetime(dispatch.end) > now() %}
                  {% set ns3.members = ns3.members + [{
                    "start": as_local(as_datetime(dispatch.start)).isoformat(),
                    "end": as_local(as_datetime(dispatch.end)).isoformat()
                  }] %}
                {% endif %}
              {% endfor %}
              {{ ns3.members }}
            gaps_dt: >
              {% set planned = state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') or [] %}
              {% set now_t = now() %}
              {% set ns = namespace(intervals=[], gaps=[], last_end=now_t.timestamp()) %}

              {# Build dispatch intervals that are still relevant #}
              {% for d in planned %}
                {% if d.start is not none and d.end is not none and as_datetime(d.end) > now() %}
                  {% set s_dt = as_local(as_datetime(d.start)) %}
                  {% set e_dt = as_local(as_datetime(d.end)) %}
                  {% if e_dt.timestamp() > now_t.timestamp() %}
                    {% set s_ts = max(s_dt.timestamp(), now_t.timestamp()) %}
                    {% set e_ts = e_dt.timestamp() %}
                    {% if e_ts > s_ts %}
                      {% set ns.intervals = ns.intervals + [(s_ts, e_ts)] %}
                    {% endif %}
                  {% endif %}
                {% endif %}
              {% endfor %}

              {% set ns.intervals = ns.intervals | sort(attribute=0) %}

              {# Compute gaps with full datetimes #}
              {% for s, e in ns.intervals %}
                {% if s > ns.last_end %}
                  {% set ns.gaps = ns.gaps + [{
                    "start": (ns.last_end | timestamp_custom("%Y-%m-%dT%H:%M:%S%z", true)),
                    "end": (s | timestamp_custom("%Y-%m-%dT%H:%M:%S%z", true))
                  }] %}
                {% endif %}
                {% set ns.last_end = max(ns.last_end, e) %}
              {% endfor %}

              {{ ns.gaps }}



    ######################################################
    # Octopus dispatch kWh
    ######################################################
    # - sensor:
    #     - name: "Octopus Total Planned Dispatch"
    #       unique_id: octopus_total_planned_dispatch
    #       icon: mdi:ev-station
    #       unit_of_measurement: "kWh"
    #       device_class: "energy"
    #       state_class: total
    #       state: >
    #         {%- set ns2 = namespace( total_dispatch = 0 ) -%}
    #         {%- if (state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') | length > 0 and state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') != None) -%}
    #           {%- for dispatch in state_attr('binary_sensor.octopus_intelligent_dispatching', 'planned_dispatches') -%}
    #             {%- set ns2.total_dispatch = ns2.total_dispatch|float + dispatch.charge_in_kwh|float%}
    #           {%- endfor -%}
    #         {%- endif  -%}
    #         {{ns2.total_dispatch|float (default=0.0)}}
    #       attributes:
    #         total_dispatches: >
    #           {%- if (state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') | length > 0 and state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') != None) -%}
    #             {{state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches')|list|count}}
    #           {%- else -%}
    #             {{0}}
    #           {%- endif  %}
    #         dispatches: >
    #           {% set ns3= namespace(members=[]) %}
    #           {%- if (state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') | length > 0 and state_attr('binary_sensor.octopus_intelligent_dispatching','planned_dispatches') != None) -%}
    #             {% for dispatch in state_attr('binary_sensor.octopus_intelligent_dispatching', 'planned_dispatches') -%}
    #               {% set ns3.members = ns3.members + [{ "dispatch":(dispatch.start|as_datetime|as_local).strftime('%H:%M') + " to " + (dispatch.end | as_datetime | as_local).strftime('%H:%M') }] %}
    #             {%- endfor -%}
    #             {{ns3.members}}
    #           {%- else -%}
    #             {{None}}
    #           {%- endif  %}

    ###############################################
    # Total Dispatch for this session
    # There is a bug waiting to happen here. 
    # if user changes the % required in the UI/app then the 
    # then remaining energy required won't get updated. ATM
    # it is a one time deal to be set before dispatch is calculated
    ###############################################


    - trigger:
        - trigger: state
          entity_id: sensor.octopus_total_planned_dispatch
        - trigger: state
          entity_id: number.octopus_intelligent_charge_target
        - trigger: state
          entity_id: switch.octopus_intelligent_smart_charge
          to: "off"

      action:
        - choose:
            # CASE A: sensor changed 0 -> non-zero: update only if helper is still 0
            #         OR the charge_target was changed very recently (race window)
            - conditions: >
                {{
                  trigger.entity_id == 'sensor.octopus_total_planned_dispatch'
                  and trigger.from_state is not none
                  and (trigger.from_state.state | float(0)) == 0
                  and (trigger.to_state.state | float(0)) != 0
                  and (
                    (states('input_number.octopus_intelligent_total_dispatch') | float(0)) == 0
                    or (
                      states['number.octopus_intelligent_charge_target'] is not none
                      and (as_timestamp(states['number.octopus_intelligent_charge_target'].last_changed)
                          >= (as_timestamp(trigger.to_state.last_changed) - 60))
                    )
                  )
                }}
              sequence:
                - service: input_number.set_value
                  target:
                    entity_id: input_number.octopus_intelligent_total_dispatch
                  data:
                    value: "{{ states('sensor.octopus_total_planned_dispatch') | float(0) }}"

            # CASE B: user changed the charge target while helper is already non-zero:
            #         allow user change to force an update to the helper.
            - conditions: >
                {{
                  trigger.entity_id == 'number.octopus_intelligent_charge_target'
                  and (states('input_number.octopus_intelligent_total_dispatch') | float(0)) != 0
                }}
              sequence:
                - service: input_number.set_value
                  target:
                    entity_id: input_number.octopus_intelligent_total_dispatch
                  data:
                    value: "{{ states('sensor.octopus_total_planned_dispatch') | float(0) }}"
            # CASE C: Smart Charge switch turned off → reset helper
            - conditions: >
                {{ trigger.entity_id == 'switch.octopus_intelligent_smart_charge' and trigger.to_state.state == 'off' }}
              sequence:
                - service: input_number.set_value
                  target:
                    entity_id: input_number.octopus_intelligent_total_dispatch
                  data:
                    value: 0

    ###############################################
    # Remaining Dispatch for this session
    ###############################################
    - sensor:
        - name: "Octopus Intelligent Remaining Dispatch"
          unique_id: octopus_intelligent_remaining_dispatch
          icon: mdi:flash
          unit_of_measurement: "kWh"
          device_class: "energy"
          state_class: total
          state: >
            {{states('input_number.octopus_intelligent_total_dispatch')|float(3) - states('sensor.zappi_charge_added_session')|float(3) }}

    ######################################################
    # Gaps in EV charging Schedule 
    ######################################################   
    - sensor:
        - name: "Octopus Next Gap Duration"
          unique_id: octopus_next_gap_duration
          unit_of_measurement: "h"
          icon: mdi:clock-outline
          state: >
            {% set min_gap_hr = 20 / 60 %}
            {% set now_t = now() %}
            {% set cutoff = today_at("23:30") %}
            {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}
            {% if gaps is not iterable %}
              0
            {% else %}
              {% set ns = namespace(found_gap=0) %}
              {% for gap in gaps %}
                {% set start = as_datetime(gap.start) %}
                {% set end = as_datetime(gap.end) %}

                {# Skip gaps that have already ended #}
                {% if end <= now_t %}
                  {% continue %}
                {% endif %}

                {# Clamp gap to now and cutoff #}
                {% set effective_start = start if start > now_t else now_t %}
                {% set effective_end = end if end < cutoff else cutoff %}

                {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                {% if dur_hr >= min_gap_hr %}
                  {% set ns.found_gap = dur_hr %}
                  {% break %}
                {% endif %}
              {% endfor %}
              {{ ns.found_gap | round(2) }}
            {% endif %}

          attributes:
            next_gap_start: >
              {% set min_gap_hr = 20 / 60 %}
              {% set now_t = now() %}
              {% set cutoff = today_at("23:30") %}
              {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}
              {% if gaps is not iterable %}
                none
              {% else %}
                {% set ns = namespace(start_time=none) %}
                {% for gap in gaps %}
                  {% set start = as_datetime(gap.start) %}
                  {% set end = as_datetime(gap.end) %}

                  {% if end <= now_t %}
                    {% continue %}
                  {% endif %}

                  {% set effective_start = start if start > now_t else now_t %}
                  {% set effective_end = end if end < cutoff else cutoff %}

                  {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                  {% if dur_hr >= min_gap_hr %}
                    {% set ns.start_time = effective_start.isoformat() %}
                    {% break %}
                  {% endif %}
                {% endfor %}
                {{ ns.start_time or '' }}
              {% endif %}

            next_gap_end: >
              {% set min_gap_hr = 20 / 60 %}
              {% set now_t = now() %}
              {% set cutoff = today_at("23:30") %}
              {% set gaps = state_attr('sensor.octopus_total_planned_dispatch', 'gaps_dt') %}
              {% if gaps is not iterable %}
                none
              {% else %}
                {% set ns = namespace(end_time=none) %}
                {% for gap in gaps %}
                  {% set start = as_datetime(gap.start) %}
                  {% set end = as_datetime(gap.end) %}

                  {% if end <= now_t %}
                    {% continue %}
                  {% endif %}

                  {% set effective_start = start if start > now_t else now_t %}
                  {% set effective_end = end if end < cutoff else cutoff %}

                  {% set dur_hr = (effective_end - effective_start).total_seconds() / 3600 %}
                  {% if dur_hr >= min_gap_hr %}
                    {% set ns.end_time = effective_end.isoformat() %}
                    {% break %}
                  {% endif %}
                {% endfor %}
                {{ ns.end_time or '' }}
              {% endif %}


    ######################################################
    # Hours of charge required
    ######################################################    
    - sensor:
      - name:  Calculated EV Charge Start Time
        unique_id: calculated_ev_charge_start_time
        device_class: "timestamp"
        icon: mdi:clock-alert
        state: >
          {% set td = timedelta(days=10) %}
          {% set target_time = states('sensor.octopus_intelligent_target_time') %}
          {% set battery_size = states('input_number.ev_battery_size')|float(0) %}
          {% set charge_pct = states('number.octopus_intelligent_charge_target')|int(100) %}
          {% set seconds = (charge_pct/100 * battery_size / 6.8 * 3600) | int %}
          {% set start = target_time | as_timestamp | int - seconds if target_time not in ['unknown','unavailable',''] else none %}
          {% set eleventhirty = (target_time | as_datetime if target_time not in ['unknown','unavailable',''] else now()).date() | as_timestamp - 1800 %}
          {% if start is not none %}
            {% set dt = (start if start < eleventhirty else eleventhirty) | as_datetime |as_local%}
          {% else %}
            {% set dt = none %}
          {% endif %}
          {{ dt.isoformat() if dt else (now() + td).isoformat() }}