########################################
# v8.2.0 Hardened battery_exportable_allowance_kwh
# v8.0.0 added nightly_battery_discharge_soc_window_limit
# Template to estimate remaining energy required to survive the day
########################################
solax_export_template_discharge_magic:
  template:
    ######################################################
    # How much Power to run the house
    ######################################################
    - sensor:
      - name: "Typical House Power"
        unique_id: typical_house_power
        unit_of_measurement: "kW"
        state: >
          {{ states('input_number.typical_house_power') }}

    ######################################################
    # How much energy can safley be exported
    ######################################################
    - sensor:
        - name: "Battery Exportable Allowance kWh"
          unique_id: battery_exportable_allowance_kwh
          unit_of_measurement: "kWh"
          icon: mdi:battery-arrow-down

          # Sensor is only available if all critical inputs exist
          availability: >
            {% set soc = states('sensor.solax_local_battery_soc') %}
            {% set op_mode = states('sensor.solax_default_operation_mode') %}
            {% set min_selfuse = states('sensor.solax_local_selfuse_battery_min_soc') %}
            {% set min_feed_in = states('sensor.solax_local_feed_in_battery_min_soc') %}
            {% set reserve_soc = states('sensor.battery_budget_reserve_soc') %}
            {% set usable = state_attr('sensor.solax_discharge_capacity','usable_capacity') %}
            {{ not (
              soc in ['unknown','unavailable','none'] or
              op_mode in ['unknown','unavailable','none'] or
              min_selfuse in ['unknown','unavailable','none'] or
              min_feed_in in ['unknown','unavailable','none'] or
              reserve_soc in ['unknown','unavailable','none'] or
              usable is none
            ) }}

          # Numeric state calculation, only runs when available
          state: >
            {% set soc = states('sensor.solax_local_battery_soc') | float %}
            {% set op_mode = states('sensor.solax_default_operation_mode') | int %}
            {% set min_selfuse = states('sensor.solax_local_selfuse_battery_min_soc') | int %}
            {% set min_feed_in = states('sensor.solax_local_feed_in_battery_min_soc') | int %}
            {% set reserve_soc = states('sensor.battery_budget_reserve_soc') | int %}
            {% set usable = state_attr('sensor.solax_discharge_capacity','usable_capacity') | float %}

            {% set return_to_min_soc = min_selfuse if op_mode == 0 else min_feed_in %}
            {% set denom = 100 - return_to_min_soc %}
            {% if denom <= 0 %}
              0
            {% else %}
              {% set target_soc = [return_to_min_soc, reserve_soc] | max %}
              {{ ([usable * ((soc - target_soc) / denom), 0] | max) | round(2) }}
            {% endif %}

          attributes:
            current_soc: "{{ states('sensor.solax_local_battery_soc') }}"
            target_soc: "{{ states('sensor.battery_budget_reserve_soc') }}"
            batt_usable_kwh: "{{ state_attr('sensor.solax_discharge_capacity','usable_capacity') }}"
            total_reserved_kwh: "{{ state_attr('sensor.battery_budget_reserve_soc', 'reserve_kwh') }}"
            note: "Energy available for export before reaching the reserve SoC."

    - sensor:
        - name: "Battery Exportable Allowance SoC"
          unique_id: battery_exportable_allowance_soc
          unit_of_measurement: "%"
          icon: mdi:battery-arrow-down

          # Sensor is only available if all critical inputs exist
          availability: >
            {% set soc = states('sensor.solax_local_battery_soc') %}
            {% set op_mode = states('sensor.solax_default_operation_mode') %}
            {% set min_selfuse = states('sensor.solax_local_selfuse_battery_min_soc') %}
            {% set min_feed_in = states('sensor.solax_local_feed_in_battery_min_soc') %}
            {% set reserve_soc = states('sensor.battery_budget_reserve_soc') %}
            {% set usable = state_attr('sensor.solax_discharge_capacity','usable_capacity') %}
            {{ not (
              soc in ['unknown','unavailable','none'] or
              op_mode in ['unknown','unavailable','none'] or
              min_selfuse in ['unknown','unavailable','none'] or
              min_feed_in in ['unknown','unavailable','none'] or
              reserve_soc in ['unknown','unavailable','none'] or
              usable is none
            ) }}

          # Numeric state calculation, only runs when available
          state: >
            {% set soc = states('sensor.solax_local_battery_soc') | float %}
            {% set op_mode = states('sensor.solax_default_operation_mode') | int %}
            {% set min_selfuse = states('sensor.solax_local_selfuse_battery_min_soc') | int %}
            {% set min_feed_in = states('sensor.solax_local_feed_in_battery_min_soc') | int %}
            {% set reserve_soc = states('sensor.battery_budget_reserve_soc') | int %}
            
            {% set return_to_min_soc = min_selfuse if op_mode == 0 else min_feed_in %}
            {% set denom = 100 - return_to_min_soc %}
            {% if denom <= 0 %}
              0
            {% else %}
              {% set target_soc = [return_to_min_soc, reserve_soc] | max %}
              {{ ([(soc - target_soc), 0] | max) | round(2) }}
            {% endif %}


    ######################################################
    # Single flag to indicate if discharge can occur
    ######################################################
    - binary_sensor:
        - name: "Battery Discharge Now"
          unique_id: battery_discharge_now
          device_class: power
          state: >
            {{ is_state('binary_sensor.ev_gap_discharge_allowed','on')
              or is_state('binary_sensor.daily_export_discharge_allowed','on')
              or is_state('binary_sensor.jit_2330_discharge_allowed','on') 
              or is_state('binary_sensor.manual_discharge_allowed','on')
              or is_state('binary_sensor.free_electric_discharge_allowed','on')}}
          attributes:
            ev_gap_discharge: "{{ is_state('binary_sensor.ev_gap_discharge_allowed','on') }}"
            daily_export_discharge: "{{ is_state('binary_sensor.daily_export_discharge_allowed','on') }}"
            jit_2330_discharge: "{{ is_state('binary_sensor.jit_2330_discharge_allowed','on') }}"
            manual_discharge: "{{ is_state('binary_sensor.manual_discharge_allowed','on') }}"
            free_discharge: "{{ is_state('binary_sensor.free_electric_discharge_allowed','on') }}"

    ######################################################
    # Discharge can occur in octopus Gaps
    ######################################################
    - binary_sensor:
        - name: "EV Gap Discharge Allowed"
          unique_id: ev_gap_discharge_allowed
          device_class: power
          state: >
            {% set a5001 = is_state('automation.solax_zappi_octopus_control','on') %}
            {% set free_electric = is_state('binary_sensor.free_electricity_today','off') %}
            {% set soc = states('sensor.solax_local_battery_soc') | float(0) %}
            
            {% set return_to_min_soc = states('sensor.solax_local_selfuse_battery_min_soc') | int(default=15) 
              if states('sensor.solax_default_operation_mode') | int == 0 
              else states('sensor.solax_local_selfuse_battery_min_soc') | int(default=15) | int %}
            {% set target_soc = [
              return_to_min_soc,
              states('sensor.battery_budget_reserve_soc') | int(default=20)
            ] | max %}

            {% set next_gap_hr = states('sensor.octopus_next_gap_duration') | float(0) %}
            {% set gap_start = state_attr('sensor.octopus_next_gap_duration', 'next_gap_start') | as_datetime %}
            {% set gap_end   = state_attr('sensor.octopus_next_gap_duration', 'next_gap_end')   | as_datetime %}

            {% set soc_window = states('input_number.battery_discharge_soc_window_limit') | float(6) %}
            {% set exportable_kwh = states('sensor.battery_exportable_allowance_kwh') | float(0) %}
            {% set ev_status = states('sensor.zappi_plug_status') | string %}
            {% set connected_for_min = (as_timestamp(now()) - as_timestamp(states.sensor.zappi_plug_status.last_changed)) / 60 %}
            {% set min_connected_min = 10 %}
            {% set solar_threshold_raw = states('sensor.solar_export_threshold') %}
            {% set solar_threshold = (solar_threshold_raw | as_datetime | as_local)
              if solar_threshold_raw not in ['unknown','unavailable','',none] else none %}
            {% set now_time = now() %}
            {% set prev_state = is_state('binary_sensor.ev_gap_discharge_allowed','on') %}
            {% set dispatch_time = (as_timestamp(now()) - states.input_number.octopus_intelligent_total_dispatch.last_changed|as_timestamp)/60 %}
            {% set dispatch = states.input_number.octopus_intelligent_total_dispatch.state|int >0 and dispatch_time > 10 and states('switch.octopus_intelligent_smart_charge') == 'on'%}

            {% set upper_threshold = target_soc + soc_window %}
            {% set lower_threshold = target_soc %}

            {{ is_state('input_boolean.battery_discharge_in_dispatch_gaps','on')
              and a5001
              and free_electric
              and dispatch
              and ev_status == 'EV Connected'
              and connected_for_min >= min_connected_min
              and next_gap_hr > 0
              and gap_start is not none
              and gap_end is not none
              and now_time >= gap_start
              and now_time < gap_end
              and exportable_kwh > (0 if target_soc > 13 else 0.300)
              and (solar_threshold is none or now_time >= solar_threshold)
              and (
                (prev_state and soc > lower_threshold)
                or (not prev_state and soc >= upper_threshold)
              )
            }}
          attributes:
            ev_status: "{{ states('sensor.zappi_plug_status') }}"
            connected_for_min: >
              {{ ((as_timestamp(now()) - as_timestamp(states.sensor.zappi_plug_status.last_changed)) / 60) | round(1) }}
            next_gap_duration_hr: "{{ states('sensor.octopus_next_gap_duration') }}"
            next_gap_start: >
              {% set g = state_attr('sensor.octopus_next_gap_duration', 'next_gap_start') %}
              {{ g if g not in ['unknown','unavailable','',none] else none }}
            next_gap_end: >
              {% set g = state_attr('sensor.octopus_next_gap_duration', 'next_gap_end') %}
              {{ g if g not in ['unknown','unavailable','',none] else none }}
            solar_threshold: >
              {% set s = states('sensor.solar_export_threshold') %}
              {{ (s | as_datetime | as_local) if s not in ['unknown','unavailable','',none] else none }}
            hysteresis_upper_threshold: >
              {% set target_soc = states('sensor.battery_budget_reserve_soc') | float(0) %}
              {% set soc_window = states('input_number.battery_discharge_soc_window_limit') | float(6) %}
              {{ (target_soc + soc_window) | round(2) }}
            hysteresis_lower_threshold: >
              {% set target_soc = states('sensor.battery_budget_reserve_soc') | float(0) %}
              {% set soc_window = states('input_number.battery_discharge_soc_window_limit') | float(6) %}
              {{ target_soc | round(2) }}

    ######################################################
    # Discharge can occur at a fixed time daily
    ######################################################
    - binary_sensor:
        - name: "Daily Export Discharge Allowed"
          unique_id: daily_export_discharge_allowed
          device_class: power
          state: >
            {% set a5001 = is_state('automation.solax_zappi_octopus_control','on') %}
            {% set planned_dispatch = states('sensor.octopus_total_planned_dispatch')| float(0)%}
            {% set allow_with_ev_connected = is_state('input_boolean.daily_export_when_ev_connected','on') and planned_dispatch < 1 %}
            {% set free_electric = is_state('binary_sensor.free_electricity_today','off')%}
            {% set soc = states('sensor.solax_local_battery_soc') | float(0) %}
            
            {% set return_to_min_soc = states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) if states('sensor.solax_default_operation_mode') | int == 0 else states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) | int %}
            {% set target_soc = [
              return_to_min_soc,
              states('sensor.battery_budget_reserve_soc') | int(default=20)
            ] | max %}

            {% set soc_window = states('input_number.daily_battery_discharge_soc_window_limit') | float(6) %}
            {% set exportable_kwh = states('sensor.battery_exportable_allowance_kwh') | float(0) %}
            {% set ev_status = states('sensor.zappi_plug_status') | string %}
            {% set now_time = now() %}
            {% set daily_export_str = states('input_datetime.daily_battery_export_time') %}
            {% set daily_export_time = (today_at(daily_export_str) | as_datetime | as_local)
              if daily_export_str not in ['unknown','unavailable','',none] else none %}
            {% set prev_state = is_state('binary_sensor.daily_export_discharge_allowed','on') %}

            {% set upper_threshold = target_soc + soc_window %}
            {% set lower_threshold = target_soc  %}

            {{ is_state('input_boolean.export_battery_daily','on')
              and a5001
              and free_electric
              and (
                    ev_status == 'EV Disconnected'
                    or (ev_status == 'EV Connected' and allow_with_ev_connected)
                  )
              and exportable_kwh > 0
              and (daily_export_time is not none and now_time >= daily_export_time)
              and (
                (prev_state and soc > lower_threshold)
                or (not prev_state and soc >= upper_threshold)
              )
            }}
          attributes:
            daily_export_time: >
              {% set t = states('input_datetime.daily_battery_export_time') %}
              {{ (today_at(t) | as_local) if t not in ['unknown','unavailable','',none] else none }}
            hysteresis_upper_threshold: >
              {% set target_soc = states('sensor.battery_budget_reserve_soc') | float(0) %}
              {% set soc_window = states('input_number.daily_battery_discharge_soc_window_limit') | float(6) %}
              {{ (target_soc + soc_window) | round(2) }}
            hysteresis_lower_threshold: >
              {% set target_soc = states('sensor.battery_budget_reserve_soc') | float(0) %}
              {% set soc_window = states('input_number.daily_battery_discharge_soc_window_limit') | float(6) %}
              {{ target_soc  }}


    ######################################################
    # JIT discharge can occur for 23:30
    # clip start to 23:29 or it all goes wrong
    ######################################################
    - trigger:
        - platform: time_pattern
          minutes: "/1"
        - platform: state
          entity_id:
            - sensor.solax_local_battery_soc
            - input_number.solax_default_discharge_limit_soc
            - input_number.battery_discharge_soc_window_limit
            - input_number.solax_inverter_capacity
            - input_number.battery_export_margin_delta
            - sensor.solax_discharge_capacity
            - sensor.battery_exportable_allowance_kwh
            - sensor.zappi_plug_status
            - input_boolean.export_battery_nightly

      binary_sensor:
        - name: "JIT 2330 Discharge Allowed"
          unique_id: jit_2330_discharge_allowed
          device_class: power

          state: >
            {% set a5001 = is_state('automation.solax_zappi_octopus_control','on') %}
            {% set planned_dispatch = states('sensor.octopus_total_planned_dispatch')| float(0)%}
            {% set allow_with_ev_connected = is_state('input_boolean.nightly_export_when_ev_connected','on') and (planned_dispatch < 1 or states('switch.octopus_intelligent_smart_charge') == 'off') %}

            {% set soc = states('sensor.solax_local_battery_soc') | float(0) %}

            {% set return_to_min_soc = states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) if states('sensor.solax_default_operation_mode') | int == 0 else states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) | int %}

            {% set min_soc = [
              return_to_min_soc,
              states('input_number.solax_default_discharge_limit_soc') | float(20)
            ] | max %}
            {# set min_soc = states('input_number.solax_default_discharge_limit_soc') | float(20) #}
            {% set soc_window = states('input_number.battery_discharge_soc_window_limit') | float(6) %}
            
            {% set inverter_cap = states('input_number.solax_inverter_capacity') | float(0) %}
            {% set margin_delta = states('input_number.battery_export_margin_delta') | float(5) %}
            
            {% set ev_status = states('sensor.zappi_plug_status') | string %}
            {% set now_ts = now().timestamp() %}

            {# --- Compute fresh JIT start timestamp --- #}
            {% set remaining_kwh_to_min = states('sensor.solax_discharge_capacity')|float(0) %}
            {% set discharge_time_sec = ((remaining_kwh_to_min / inverter_cap) * 3600) if inverter_cap > 0 else 0 %}
            {# set target_ts = (today_at('23:30:00') + timedelta(minutes=margin_delta)).timestamp() #}
            {# --- Compute 23:30 + margin_delta, safe across midnight --- #}
            {% set base_time = today_at('23:30:00') %}
            {% set adjusted = base_time + timedelta(minutes=margin_delta) %}
            {% if adjusted < base_time %}
              {% set adjusted = adjusted + timedelta(days=1) %}
            {% endif %}
            {% set target_ts = adjusted.timestamp() %}
            {% set calc_start_ts = (target_ts - discharge_time_sec)|float %}
            {# --- Clip start time so it never exceeds 23:25 --- #}
            {% set clip_cutoff = today_at('23:25:00').timestamp()|float %}
            {% set calc_start_ts = [calc_start_ts, clip_cutoff] | min %}
            {###### need to clip the start to 23:29 ##########}
            {# --- Use previously locked timestamp if present --- #}
            {% set prev_locked_ts = state_attr('binary_sensor.jit_2330_discharge_allowed','locked_start') | float(0) %}
            {% set just_in_time_start_ts = prev_locked_ts if prev_locked_ts > 0 else calc_start_ts %}

            {# --- Hysteresis thresholds --- #}
            {% set upper_threshold = min_soc + soc_window %}
            {% set lower_threshold = min_soc %}
            {% set was_on = is_state('binary_sensor.jit_2330_discharge_allowed', 'on') %}
            {% set turn_on = soc >= upper_threshold %}
            {% set keep_on = was_on and soc > lower_threshold %}
            {% set exportable_kwh = states('sensor.battery_exportable_allowance_kwh') | float(0) %}

            {{ is_state('input_boolean.export_battery_nightly','on')
              and a5001
              and (
                    ev_status == 'EV Disconnected'
                    or (ev_status == 'EV Connected' and allow_with_ev_connected)
                  )
              and remaining_kwh_to_min > 0
              and now_ts >= just_in_time_start_ts
              and (turn_on or keep_on)
              
            }}
            {# and exportable_kwh > 0.300 #}

          attributes:
            locked_start: >
              {% set inverter_cap = states('input_number.solax_inverter_capacity') | float(0) %}
              {% set margin_delta = states('input_number.battery_export_margin_delta') | float(5) %}
              {% set remaining_kwh_to_min =states('sensor.solax_discharge_capacity')|float(0) %}
              {% set discharge_time_sec = ((remaining_kwh_to_min / inverter_cap) * 3600) if inverter_cap > 0 else 0 %}
              {# set target_ts = (today_at('23:30:00') + timedelta(minutes=margin_delta)).timestamp() #}
              {# --- Compute 23:30 + margin_delta, safe across midnight --- #}
              {% set base_time = today_at('23:30:00') %}
              {% set adjusted = base_time + timedelta(minutes=margin_delta) %}
              {% if adjusted < base_time %}
                {% set adjusted = adjusted + timedelta(days=1) %}
              {% endif %}
              {% set target_ts = adjusted.timestamp() %}
              {% set calc_start_ts = (target_ts - discharge_time_sec)|float %}
              {# --- Clip start time so it never exceeds 23:25 --- #}
              {% set clip_cutoff = today_at('23:25:00').timestamp()|float %}
              {% set calc_start_ts = [calc_start_ts, clip_cutoff] | min %}

              {% set prev_ts = state_attr('binary_sensor.jit_2330_discharge_allowed','locked_start') | float(0) %}

              {% if is_state('binary_sensor.jit_2330_discharge_allowed','on') %}
                {{ prev_ts if prev_ts > 0 else calc_start_ts }}
              {% else %}
                0
              {% endif %}

            just_in_time_start_2330: >
              {% set ts = state_attr('binary_sensor.jit_2330_discharge_allowed','locked_start') | float(0) %}
              {% if ts > 0 %}
                {{ ts | timestamp_custom('%Y-%m-%d %H:%M:%S', true) }}
              {% else %}
                {% set remaining_kwh_to_min =states('sensor.solax_discharge_capacity')|float(0) %}
                {% set inverter_cap = states('input_number.solax_inverter_capacity') | float(0) %}
                {% set margin_delta = states('input_number.battery_export_margin_delta') | float(5) %}
                {% set discharge_time_sec = ((remaining_kwh_to_min / inverter_cap) * 3600) if inverter_cap > 0 else 0 %}
                {# set target_ts = (today_at('23:30:00') + timedelta(minutes=margin_delta)).timestamp() #}
                {# --- Compute 23:30 + margin_delta, safe across midnight --- #}
                {% set base_time = today_at('23:30:00') %}
                {% set adjusted = base_time + timedelta(minutes=margin_delta) %}
                {% if adjusted < base_time %}
                  {% set adjusted = adjusted + timedelta(days=1) %}
                {% endif %}
                {% set target_ts = adjusted.timestamp() %}
                {% set calc_start_ts = (target_ts - discharge_time_sec)|float %}
                {# --- Clip start time so it never exceeds 23:25 --- #}
                {% set clip_cutoff = today_at('23:25:00').timestamp()|float %}
                {% set calc_start_ts = [calc_start_ts, clip_cutoff] | min %}
                {{calc_start_ts|as_datetime|as_local}}
              {% endif %}

            upper_threshold: "{{ (states('input_number.solax_default_discharge_limit_soc') | float(20)) + (states('input_number.battery_discharge_soc_window_limit') | float(6)) }}"
            lower_threshold: "{{ states('input_number.solax_default_discharge_limit_soc') }}"
            margin_delta: "{{ states('input_number.battery_export_margin_delta') }}"
            exportable_kwh: "{{ states('sensor.battery_exportable_allowance_kwh') }}"
            ev_status: "{{ states('sensor.zappi_plug_status') }}"


    ######################################################
    # Free Electric prep discharge can occur
    ######################################################
    - binary_sensor:
        - name: "Free Electric Discharge Allowed"
          unique_id: free_electric_discharge_allowed
          device_class: power
          state: >
            {% set a5001 = is_state('automation.solax_zappi_octopus_control','on') %}
            {% set return_to_min_soc = states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) if states('sensor.solax_default_operation_mode') | int == 0 else states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) | int %}
            {% set target_soc = [
              return_to_min_soc,
              states('input_number.octopus_free_session_battery_prep_soc')|int(default=20)
            ] | max %}

            {% set soc_window = states('input_number.nightly_battery_discharge_soc_window_limit') | float(6) %}
            {% set soc = states('sensor.solax_local_battery_soc') | float(0) %}
            {% set ev_status = states('sensor.zappi_plug_status') | string %}
            {% set now_time = now() %}

            {% set prep_time_str = states('input_datetime.octopus_free_electricity_prep') %}
            {% set prep_time = (
              today_at(prep_time_str) | as_datetime | as_local
            ) if prep_time_str not in ['unknown','unavailable','',none] else none %}

            {% set start_str = states('sensor.octopus_free_electricity_start') %}
            {% set start_time = (
              as_datetime(start_str) | as_local
            ) if start_str not in ['unknown','unavailable','',none] else none %}

            {% set free_today = is_state('binary_sensor.free_electricity_today','on') %}
            {% set prev_state = is_state('binary_sensor.free_electric_discharge_allowed','on') %}

            {% set discharge_allowed = is_state('input_boolean.octopus_free_electric_soc_use','off')%}
            {% set free_electric_soc = is_state('input_boolean.octopus_free_electric_soc_use','off')%}
            {% set upper_threshold = soc_window + target_soc %}
            {% set lower_threshold = target_soc %}

            {# ---- Determine active window safely ---- #}
            {% set valid_window = (
              prep_time is not none and
              start_time is not none and
              start_time > now_time
            ) %}

            {% set active_window_hours = (
              ((start_time - prep_time).total_seconds() / 3600)
              if valid_window else 0
            ) | float(0) %}

            {{ valid_window
              and a5001
              and free_electric_soc
              and discharge_allowed
              and free_today
              and ev_status != 'Charging'
              and now_time >= prep_time
              and now_time < (prep_time + timedelta(hours=active_window_hours))
              and (
                (prev_state and soc > lower_threshold)
                or (not prev_state and soc > upper_threshold)
              )
            }}


          attributes:
            free_electric_prep_time: >
              {% set t = states('input_datetime.octopus_free_electricity_prep') %}
              {{ (today_at(t) | as_local) if t not in ['unknown','unavailable','',none] else none }}
            hysteresis_upper_threshold: >
              {% set prep_soc = states('input_number.octopus_free_session_battery_prep_soc') | float(0) %}
              {{ ( 100 ) | round(2) }}
            hysteresis_lower_threshold: >
              {% set prep_soc = states('input_number.octopus_free_session_battery_prep_soc') | float(0) %}
              {{ prep_soc | round(2) }}

    ######################################################
    # Manual discharge can occur
    ######################################################
    - trigger:
        # Re-evaluate and act whenever the user requests manual discharge or conditions change
        - platform: state
          entity_id:
            - input_boolean.export_battery_manual
            - sensor.solax_local_battery_soc
            - sensor.zappi_plug_status
            - sensor.solax_local_feed_in_battery_min_soc
            - sensor.solax_local_selfuse_battery_min_soc
            - input_number.solax_manual_forced_discharge_limit_soc
      binary_sensor:
        - name: "Manual Discharge Allowed"
          unique_id: manual_discharge_allowed
          device_class: power
          state: >
            {% set a5001 = is_state('automation.solax_zappi_octopus_control','on') %}
            {% set return_to_min_soc = states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) if states('sensor.solax_default_operation_mode') | int == 0 else states('sensor.solax_local_selfuse_battery_min_soc')|int(default=15) | int %}
            {% set target_soc = [
              return_to_min_soc,
              states('input_number.solax_manual_forced_discharge_limit_soc') | int(default=20)
            ] | max %}
            {% set soc_window = states('input_number.battery_discharge_soc_window_limit') | float(6) %}
            {% set soc = states('sensor.solax_local_battery_soc') | float(0) %}
            {% set ev_status = states('sensor.zappi_plug_status') | string %}
            {% set manual_discharge = is_state('input_boolean.export_battery_manual', 'on') %}
            {% set prev_state = is_state('binary_sensor.manual_discharge_allowed', 'on') %}
            {% set upper_threshold = soc_window+target_soc  %}
            {% set lower_threshold = target_soc %}

            {{ manual_discharge
              and a5001
              and ev_status != 'Charging'
              and (
                (prev_state and soc > lower_threshold)
                or (not prev_state and soc >= upper_threshold)
              )
            }}








